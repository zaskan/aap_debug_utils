---
- name: Create a directory for the database restore to live.
  file:
    path: '{{ backup_dir.rstrip("/") }}/restore/'
    mode: 0775
    owner: root
    state: directory
  changed_when: true
  notify: Remove the restore directory.

- name: Upload the backup tarball to the server.
  copy:
    dest: '{{ backup_dir.rstrip("/") }}/restore/{{ restore_file_prefix }}.tar.gz'
    mode: 0664
    owner: root
    src: '{{ restore_backup_file }}'

- name: Uncompress the backup file.
  unarchive:
    src: '{{ backup_dir.rstrip("/") }}/restore/{{ restore_file_prefix }}.tar.gz'
    dest: '{{ backup_dir.rstrip("/") }}/restore/'
    remote_src: true

- name: Check backup compatibility
  when: inventory_hostname in groups.get('automationcontroller', []) | union(groups.get('automationhub', [])) | union(groups.get('automationedacontroller', []))
  block:
    - name: Get AAP version from backup
      ansible.builtin.slurp:
        src: '{{ backup_dir.rstrip("/") }}/restore/VERSION'
      register: _aap_backup_version
      ignore_errors: true
      run_once: true

    - name: Check AAP version from backup
      ansible.builtin.assert:
        that:
          - _aap_backup_version is not failed
          - _aap_backup_version.content | b64decode | trim | length
        fail_msg: "Not able to identify AAP version from backup and this backup is not compatible."
      run_once: true

    - name: Assert installer and backup are compatible
      ansible.builtin.assert:
        that:
          - _aap_backup_version.content | b64decode | trim == automation_platform_version
        fail_msg: "AAP {{ _aap_backup_version.content | b64decode | trim }} backup can't be used with AAP {{ automation_platform_version }} installer."
      run_once: true

    - name: Get AAP version
      ansible.builtin.slurp:
        src: "/etc/ansible-automation-platform/VERSION"
      register: _aap_version
      ignore_errors: true

    - name: Check AAP version
      ansible.builtin.assert:
        that:
          - _aap_version is not failed
          - _aap_version.content | b64decode | trim | length
        fail_msg: "Not able to identify installed AAP version. The node must have AAP {{ _aap_backup_version.content | b64decode | trim }} installed."

    - name: Assert backup is compatible with current installed version
      ansible.builtin.assert:
        that:
          - _aap_version.content | b64decode | trim == _aap_backup_version.content | b64decode | trim
        fail_msg: "Backup version {{ _aap_backup_version.content | b64decode | trim }} does not match with the installed version {{ _aap_version.content | b64decode | trim }}."
        success_msg: "Backup version matches with the installed version."

- name: Check for a host specific directory
  stat:
    path: '{{ backup_dir.rstrip("/") }}/restore/{{ inventory_hostname }}.tar.gz'
  register: host_archive

- name: Register presence of host archive
  set_fact:
    has_host_archive: '{{ host_archive.stat.exists }}'

- name: Cleanup any stale backup restore version
  file:
    path: '{{ backup_dir.rstrip("/") }}/restore/version'
    state: absent
  ignore_errors: true

- name: Check for certificate authority archive
  stat:
    path: '{{ backup_dir.rstrip("/") }}/restore/ca.tar.gz'
  register: ca_archive

- name: Extract the certificate authority archive.
  unarchive:
    src: '{{ backup_dir.rstrip("/") }}/restore/ca.tar.gz'
    dest: '{{ backup_dir.rstrip("/") }}/restore/'
    remote_src: true
  when:
    - ca_archive.stat.exists
    - groups['aap_ca_server'] | default([]) | length
    - inventory_hostname in groups['aap_ca_server'][0] | default([])

- name: Extract the common archive.
  unarchive:
    src: '{{ backup_dir.rstrip("/") }}/restore/common.tar.gz'
    dest: '{{ backup_dir.rstrip("/") }}/restore/'
    remote_src: true
  when:
    - groups['automationcontroller'] | default([]) | length

- name: Extract the postgres archive.
  unarchive:
    src: '{{ backup_dir.rstrip("/") }}/restore/postgres.tar.gz'
    dest: '{{ backup_dir.rstrip("/") }}/restore/'
    remote_src: true
  when:
    - groups['automationcontroller'] | default([]) | length
    - inventory_hostname == groups['automationcontroller'][0]

- name: Extract the automationhub archive.
  unarchive:
    src: '{{ backup_dir.rstrip("/") }}/restore/automationhub.tar.gz'
    dest: '{{ backup_dir.rstrip("/") }}/restore/'
    remote_src: true
  when:
    - inventory_hostname in groups['automationhub'] | default([])

- name: Extract the sso archive.
  unarchive:
    src: '{{ backup_dir.rstrip("/") }}/restore/sso.tar.gz'
    dest: '{{ backup_dir.rstrip("/") }}/restore/'
    remote_src: true
  when:
    - inventory_hostname in groups['sso'] | default([])

- name: Extract the automationedacontroller archive.
  unarchive:
    src: '{{ backup_dir.rstrip("/") }}/restore/automationedacontroller.tar.gz'
    dest: '{{ backup_dir.rstrip("/") }}/restore/'
    remote_src: true
  when:
    - inventory_hostname in groups['automationedacontroller'] | default([])

- name: Extract the host specific archive
  unarchive:
    src: '{{ backup_dir.rstrip("/") }}/restore/{{ inventory_hostname }}.tar.gz'
    dest: '{{ backup_dir.rstrip("/") }}/restore/'
    remote_src: true
  when: has_host_archive | bool

- name: Changing the permission of the restore directory after extraction of backup archive
  file:
    path: '{{ backup_dir.rstrip("/") }}/restore'
    state: directory
    mode: 0755
    owner: root

- block:
    - name: controller | Stop Web Service.
      service:
        name: nginx
        state: stopped
      notify: start web service.

    - name: controller | Stop supervisor.
      service:
        name: supervisord
        state: stopped
      notify: start supervisord.

    - name: controller | Get tower db settings
      shell: "awx-manage print_settings | grep '^DATABASES'"
      register: results
      changed_when: False
      no_log: "{{ _no_log }}"

    - name: controller | Ingest database settings
      set_fact:
        controller_db_settings: "{{ results.stdout | regex_replace('DATABASES\\s+= ', '') }}"
      no_log: "{{ _no_log }}"

  when:
    - inventory_hostname in groups['automationcontroller'] | default([])

- block:
    - name: hub | Get hub database settings
      shell: "grep '^DATABASES' /etc/pulp/settings.py"
      register: ah_database_settings
      changed_when: false
      no_log: "{{ _no_log }}"

    - name: hub | Ingest hub database settings
      set_fact:
        automationhub_db_settings: "{{ ah_database_settings.stdout | regex_replace('DATABASES\\s+= ', '') }}"
      no_log: "{{ _no_log }}"
  when:
    - inventory_hostname in groups['automationhub'] | default([])

- block:
    - include_vars: ../roles/sso/defaults/main.yml

    - set_fact:
        routable_hostname: "{{ sso_redirect_host | default(ansible_host) }}"
      when: not routable_hostname | default('') | length

    - name: Stop SSO Service
      service:
        name: '{{ sso_app_name }}'
        enabled: yes
        state: stopped
  when:
    - inventory_hostname in groups['sso'] | default([])

- block:

    - name: Slurp eda settings file
      slurp:
        src: '/etc/ansible-automation-platform/eda/environment'
      register: eda_settings

    - set_fact:
        automationedacontroller_db_settings:
          name: "{{ eda_settings['content'] | b64decode | regex_search('EDA_DB_NAME=(.+)', '\\1') | combine }}"
          host: "{{ eda_settings['content'] | b64decode | regex_search('EDA_DB_HOST=(.+)', '\\1') | combine }}"
          port: "{{ eda_settings['content'] | b64decode | regex_search('EDA_DB_PORT=(.+)', '\\1') | combine }}"
          user: "{{ eda_settings['content'] | b64decode | regex_search('EDA_DB_USER=(.+)', '\\1') | combine }}"
          password: "{{ eda_settings['content'] | b64decode | regex_search('EDA_DB_PASSWORD=(.+)', '\\1') | combine }}"

  when:
    - inventory_hostname in groups['automationedacontroller'] | default([])
